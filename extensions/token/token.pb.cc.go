// Code generated by protoc-gen-cc-gateway. DO NOT EDIT.
// source: token/token.proto

/*
Package token contains
  *   chaincode methods names {service_name}Chaincode_{method_name}
  *   chaincode interface definition {service_name}Chaincode
  *   chaincode gateway definition {service_name}}Gateway
  *   chaincode service to cckit router registration func
*/
package token

import (
	context "context"
	_ "embed"

	cckit_gateway "github.com/hyperledger-labs/cckit/gateway"
	cckit_router "github.com/hyperledger-labs/cckit/router"
	cckit_defparam "github.com/hyperledger-labs/cckit/router/param/defparam"
	cckit_sdk "github.com/hyperledger-labs/cckit/sdk"
	"google.golang.org/protobuf/types/known/emptypb"
)

// TokenServiceChaincode method names
const (

	// TokenServiceChaincodeMethodPrefix allows to use multiple services with same method names in one chaincode
	TokenServiceChaincodeMethodPrefix = "TokenService."

	TokenServiceChaincode_GetConfig = TokenServiceChaincodeMethodPrefix + "GetConfig"

	TokenServiceChaincode_SetConfig = TokenServiceChaincodeMethodPrefix + "SetConfig"

	TokenServiceChaincode_GetToken = TokenServiceChaincodeMethodPrefix + "GetToken"

	TokenServiceChaincode_GetDefaultToken = TokenServiceChaincodeMethodPrefix + "GetDefaultToken"

	TokenServiceChaincode_CreateTokenType = TokenServiceChaincodeMethodPrefix + "CreateTokenType"

	TokenServiceChaincode_GetTokenType = TokenServiceChaincodeMethodPrefix + "GetTokenType"

	TokenServiceChaincode_ListTokenTypes = TokenServiceChaincodeMethodPrefix + "ListTokenTypes"

	TokenServiceChaincode_UpdateTokenType = TokenServiceChaincodeMethodPrefix + "UpdateTokenType"

	TokenServiceChaincode_DeleteTokenType = TokenServiceChaincodeMethodPrefix + "DeleteTokenType"

	TokenServiceChaincode_GetTokenGroups = TokenServiceChaincodeMethodPrefix + "GetTokenGroups"

	TokenServiceChaincode_CreateTokenGroup = TokenServiceChaincodeMethodPrefix + "CreateTokenGroup"

	TokenServiceChaincode_GetTokenGroup = TokenServiceChaincodeMethodPrefix + "GetTokenGroup"

	TokenServiceChaincode_DeleteTokenGroup = TokenServiceChaincodeMethodPrefix + "DeleteTokenGroup"
)

// TokenServiceChaincode chaincode methods interface
type TokenServiceChaincode interface {
	GetConfig(cckit_router.Context, *emptypb.Empty) (*Config, error)

	SetConfig(cckit_router.Context, *Config) (*Config, error)

	GetToken(cckit_router.Context, *TokenId) (*Token, error)

	GetDefaultToken(cckit_router.Context, *emptypb.Empty) (*Token, error)

	CreateTokenType(cckit_router.Context, *CreateTokenTypeRequest) (*TokenType, error)

	GetTokenType(cckit_router.Context, *TokenTypeId) (*TokenType, error)

	ListTokenTypes(cckit_router.Context, *emptypb.Empty) (*TokenTypes, error)

	UpdateTokenType(cckit_router.Context, *UpdateTokenTypeRequest) (*TokenType, error)

	DeleteTokenType(cckit_router.Context, *TokenTypeId) (*TokenType, error)

	GetTokenGroups(cckit_router.Context, *TokenTypeId) (*TokenGroups, error)

	CreateTokenGroup(cckit_router.Context, *CreateTokenGroupRequest) (*TokenGroup, error)

	GetTokenGroup(cckit_router.Context, *TokenGroupId) (*TokenGroup, error)

	DeleteTokenGroup(cckit_router.Context, *TokenGroupId) (*Token, error)
}

// RegisterTokenServiceChaincode registers service methods as chaincode router handlers
func RegisterTokenServiceChaincode(r *cckit_router.Group, cc TokenServiceChaincode) error {

	r.Query(TokenServiceChaincode_GetConfig,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetConfig(ctx, ctx.Param().(*emptypb.Empty))
		},
		cckit_defparam.Proto(&emptypb.Empty{}))

	r.Invoke(TokenServiceChaincode_SetConfig,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.SetConfig(ctx, ctx.Param().(*Config))
		},
		cckit_defparam.Proto(&Config{}))

	r.Query(TokenServiceChaincode_GetToken,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetToken(ctx, ctx.Param().(*TokenId))
		},
		cckit_defparam.Proto(&TokenId{}))

	r.Query(TokenServiceChaincode_GetDefaultToken,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetDefaultToken(ctx, ctx.Param().(*emptypb.Empty))
		},
		cckit_defparam.Proto(&emptypb.Empty{}))

	r.Invoke(TokenServiceChaincode_CreateTokenType,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.CreateTokenType(ctx, ctx.Param().(*CreateTokenTypeRequest))
		},
		cckit_defparam.Proto(&CreateTokenTypeRequest{}))

	r.Query(TokenServiceChaincode_GetTokenType,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetTokenType(ctx, ctx.Param().(*TokenTypeId))
		},
		cckit_defparam.Proto(&TokenTypeId{}))

	r.Query(TokenServiceChaincode_ListTokenTypes,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.ListTokenTypes(ctx, ctx.Param().(*emptypb.Empty))
		},
		cckit_defparam.Proto(&emptypb.Empty{}))

	r.Invoke(TokenServiceChaincode_UpdateTokenType,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.UpdateTokenType(ctx, ctx.Param().(*UpdateTokenTypeRequest))
		},
		cckit_defparam.Proto(&UpdateTokenTypeRequest{}))

	r.Invoke(TokenServiceChaincode_DeleteTokenType,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.DeleteTokenType(ctx, ctx.Param().(*TokenTypeId))
		},
		cckit_defparam.Proto(&TokenTypeId{}))

	r.Query(TokenServiceChaincode_GetTokenGroups,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetTokenGroups(ctx, ctx.Param().(*TokenTypeId))
		},
		cckit_defparam.Proto(&TokenTypeId{}))

	r.Invoke(TokenServiceChaincode_CreateTokenGroup,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.CreateTokenGroup(ctx, ctx.Param().(*CreateTokenGroupRequest))
		},
		cckit_defparam.Proto(&CreateTokenGroupRequest{}))

	r.Query(TokenServiceChaincode_GetTokenGroup,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetTokenGroup(ctx, ctx.Param().(*TokenGroupId))
		},
		cckit_defparam.Proto(&TokenGroupId{}))

	r.Invoke(TokenServiceChaincode_DeleteTokenGroup,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.DeleteTokenGroup(ctx, ctx.Param().(*TokenGroupId))
		},
		cckit_defparam.Proto(&TokenGroupId{}))

	return nil
}

//go:embed token.swagger.json
var TokenServiceSwagger []byte

// NewTokenServiceGateway creates gateway to access chaincode method via chaincode service
func NewTokenServiceGateway(sdk cckit_sdk.SDK, channel, chaincode string, opts ...cckit_gateway.Opt) *TokenServiceGateway {
	return NewTokenServiceGatewayFromInstance(
		cckit_gateway.NewChaincodeInstanceService(
			sdk,
			&cckit_gateway.ChaincodeLocator{Channel: channel, Chaincode: chaincode},
			opts...,
		))
}

func NewTokenServiceGatewayFromInstance(chaincodeInstance cckit_gateway.ChaincodeInstance) *TokenServiceGateway {
	return &TokenServiceGateway{
		ChaincodeInstance: chaincodeInstance,
	}
}

// gateway implementation
// gateway can be used as kind of SDK, GRPC or REST server ( via grpc-gateway or clay )
type TokenServiceGateway struct {
	ChaincodeInstance cckit_gateway.ChaincodeInstance
}

func (c *TokenServiceGateway) Invoker() cckit_gateway.ChaincodeInstanceInvoker {
	return cckit_gateway.NewChaincodeInstanceServiceInvoker(c.ChaincodeInstance)
}

// ServiceDef returns service definition
func (c *TokenServiceGateway) ServiceDef() cckit_gateway.ServiceDef {
	return cckit_gateway.NewServiceDef(
		_TokenService_serviceDesc.ServiceName,
		TokenServiceSwagger,
		&_TokenService_serviceDesc,
		c,
		RegisterTokenServiceHandlerFromEndpoint,
	)
}

func (c *TokenServiceGateway) GetConfig(ctx context.Context, in *emptypb.Empty) (*Config, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, TokenServiceChaincode_GetConfig, []interface{}{in}, &Config{}); err != nil {
		return nil, err
	} else {
		return res.(*Config), nil
	}
}

func (c *TokenServiceGateway) SetConfig(ctx context.Context, in *Config) (*Config, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Invoke(ctx, TokenServiceChaincode_SetConfig, []interface{}{in}, &Config{}); err != nil {
		return nil, err
	} else {
		return res.(*Config), nil
	}
}

func (c *TokenServiceGateway) GetToken(ctx context.Context, in *TokenId) (*Token, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, TokenServiceChaincode_GetToken, []interface{}{in}, &Token{}); err != nil {
		return nil, err
	} else {
		return res.(*Token), nil
	}
}

func (c *TokenServiceGateway) GetDefaultToken(ctx context.Context, in *emptypb.Empty) (*Token, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, TokenServiceChaincode_GetDefaultToken, []interface{}{in}, &Token{}); err != nil {
		return nil, err
	} else {
		return res.(*Token), nil
	}
}

func (c *TokenServiceGateway) CreateTokenType(ctx context.Context, in *CreateTokenTypeRequest) (*TokenType, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Invoke(ctx, TokenServiceChaincode_CreateTokenType, []interface{}{in}, &TokenType{}); err != nil {
		return nil, err
	} else {
		return res.(*TokenType), nil
	}
}

func (c *TokenServiceGateway) GetTokenType(ctx context.Context, in *TokenTypeId) (*TokenType, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, TokenServiceChaincode_GetTokenType, []interface{}{in}, &TokenType{}); err != nil {
		return nil, err
	} else {
		return res.(*TokenType), nil
	}
}

func (c *TokenServiceGateway) ListTokenTypes(ctx context.Context, in *emptypb.Empty) (*TokenTypes, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, TokenServiceChaincode_ListTokenTypes, []interface{}{in}, &TokenTypes{}); err != nil {
		return nil, err
	} else {
		return res.(*TokenTypes), nil
	}
}

func (c *TokenServiceGateway) UpdateTokenType(ctx context.Context, in *UpdateTokenTypeRequest) (*TokenType, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Invoke(ctx, TokenServiceChaincode_UpdateTokenType, []interface{}{in}, &TokenType{}); err != nil {
		return nil, err
	} else {
		return res.(*TokenType), nil
	}
}

func (c *TokenServiceGateway) DeleteTokenType(ctx context.Context, in *TokenTypeId) (*TokenType, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Invoke(ctx, TokenServiceChaincode_DeleteTokenType, []interface{}{in}, &TokenType{}); err != nil {
		return nil, err
	} else {
		return res.(*TokenType), nil
	}
}

func (c *TokenServiceGateway) GetTokenGroups(ctx context.Context, in *TokenTypeId) (*TokenGroups, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, TokenServiceChaincode_GetTokenGroups, []interface{}{in}, &TokenGroups{}); err != nil {
		return nil, err
	} else {
		return res.(*TokenGroups), nil
	}
}

func (c *TokenServiceGateway) CreateTokenGroup(ctx context.Context, in *CreateTokenGroupRequest) (*TokenGroup, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Invoke(ctx, TokenServiceChaincode_CreateTokenGroup, []interface{}{in}, &TokenGroup{}); err != nil {
		return nil, err
	} else {
		return res.(*TokenGroup), nil
	}
}

func (c *TokenServiceGateway) GetTokenGroup(ctx context.Context, in *TokenGroupId) (*TokenGroup, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, TokenServiceChaincode_GetTokenGroup, []interface{}{in}, &TokenGroup{}); err != nil {
		return nil, err
	} else {
		return res.(*TokenGroup), nil
	}
}

func (c *TokenServiceGateway) DeleteTokenGroup(ctx context.Context, in *TokenGroupId) (*Token, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Invoke(ctx, TokenServiceChaincode_DeleteTokenGroup, []interface{}{in}, &Token{}); err != nil {
		return nil, err
	} else {
		return res.(*Token), nil
	}
}
